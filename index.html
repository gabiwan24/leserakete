<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>LeseRakete</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸš€</text></svg>">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Playwrite+DE+Grund:wght@100..400&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans', sans-serif;
            overscroll-behavior: none;
            user-select: none;
            -webkit-user-select: none;
            background-color: #f9fafb;
        }

        #spiel {
            touch-action: none;
            /* FÃ¼r weiche ÃœbergÃ¤nge */
            transition: opacity 1s ease-in-out;
        }
        
        .font-learning { font-family: 'Playwrite DE Grund', cursive; }
        
        input[type=number]::-webkit-inner-spin-button, 
        input[type=number]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }
        input[type=number] { -moz-appearance: textfield; }

        .animate-pop-in { animation: popIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; }
        @keyframes popIn { 0% { opacity: 0; transform: scale(0.8); } 100% { opacity: 1; transform: scale(1); } }

        .card-shadow { box-shadow: 0 3px 0 rgba(0,0,0,0.15), 0 5px 10px rgba(0,0,0,0.1); }
        .fade-out { animation: fadeOut 0.5s ease-out forwards; }
        @keyframes fadeOut { from { opacity: 1; visibility: visible; } to { opacity: 0; visibility: hidden; } }

        .animal-icon { filter: grayscale(100%) opacity(0.4); transform: scale(0.9); transition: all 0.5s ease; }
        .animal-active { filter: grayscale(0%) opacity(1); transform: scale(1.3); z-index: 10; }
        
        .touch-target { cursor: pointer; touch-action: manipulation; }

        .safe-area-pb {
            padding-bottom: env(safe-area-inset-bottom, 20px);
        }
        
        .toggle-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.5rem;
        }

        /* Scrollbar hiding */
        .scrollbar-hide::-webkit-scrollbar { display: none; }
        .scrollbar-hide { -ms-overflow-style: none; scrollbar-width: none; }
    </style>
</head>
<body class="w-screen h-[100dvh] overflow-hidden flex flex-col select-none">

    <div id="intro-screen" class="fixed inset-0 z-[100] bg-white flex items-center justify-center transition-opacity duration-500">
        <h1 id="intro-title" class="text-4xl md:text-6xl font-bold text-blue-600 animate-bounce font-learning text-center opacity-0 transition-opacity duration-500">LeseRakete ðŸš€</h1>
    </div>

    <div id="swipe-feedback-bg" class="absolute inset-0 z-0 pointer-events-none transition-colors duration-150"></div>

    <!-- Overlay fÃ¼r Hinweise (Toast) -->
    <div id="game-toast" class="fixed top-1/4 left-0 right-0 z-[80] flex justify-center pointer-events-none opacity-0 transition-all duration-500 transform scale-95">
        <div class="bg-blue-600/90 backdrop-blur text-white px-6 py-4 rounded-2xl shadow-xl font-bold text-xl text-center mx-4 border border-blue-400">
            <span id="game-toast-text">Hinweis</span>
        </div>
    </div>

    <!-- Overlay fÃ¼r WÃ¶rterbuch -->
    <div id="dictionary-overlay" class="fixed inset-0 z-[90] bg-white hidden flex-col">
        <div class="p-4 border-b border-gray-200 flex justify-between items-center bg-gray-50">
            <h2 class="text-2xl font-bold text-blue-600 font-learning">WÃ¶rterbuch ðŸ“–</h2>
            <button onclick="toggleDictionary(false)" class="text-gray-500 hover:text-red-500 p-2">
                <svg class="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
        <div id="dictionary-content" class="flex-grow overflow-y-auto p-4 space-y-6"></div>
    </div>

    <div id="app" class="relative w-full h-full z-10 flex flex-col hidden opacity-0 transition-opacity duration-500">

        <!-- 1. SETUP (MenÃ¼) -->
        <div id="startbildschirm" class="flex flex-col h-full bg-white z-50">
            
            <!-- SCROLLABLE CONTENT -->
            <div class="flex-grow overflow-y-auto p-4 pb-2">
                <div class="flex justify-center items-center mb-4 relative">
                    <h1 class="text-3xl font-bold text-blue-600 shrink-0 font-learning">LeseRakete ðŸš€</h1>
                    <button onclick="toggleDictionary(true)" class="absolute right-0 top-1/2 -translate-y-1/2 text-2xl p-2 hover:scale-110 transition-transform">ðŸ“–</button>
                </div>

                <div class="flex flex-col gap-3">
                    
                    <!-- Optionen & Modus -->
                    <div class="bg-gray-50 rounded-xl p-2 border border-gray-200 shrink-0 flex flex-col gap-2">
                        <div class="flex gap-2">
                            <div class="flex-1 flex flex-col justify-center items-center bg-white border border-gray-200 rounded-lg p-2 shadow-sm">
                                <span class="text-[10px] font-bold text-gray-400 uppercase mb-1">Silben</span>
                                <div class="flex items-center justify-center gap-1 text-base font-bold text-blue-600">
                                    <input type="number" id="min-silben" value="1" min="1" max="5" class="w-6 text-center border-b-2 border-gray-300 bg-transparent text-red-600 text-lg focus:border-blue-500 outline-none p-0" onfocus="this.select()" onchange="state.settings.manualSyllables = true">
                                    <span>-</span>
                                    <input type="number" id="max-silben" value="2" min="1" max="5" class="w-6 text-center border-b-2 border-gray-300 bg-transparent text-red-600 text-lg focus:border-blue-500 outline-none p-0" onfocus="this.select()" onchange="state.settings.manualSyllables = true">
                                </div>
                            </div>
                            <div class="flex-[1.5] flex flex-col justify-center items-center bg-white border border-gray-200 rounded-lg p-2 shadow-sm">
                                <label class="text-[10px] font-bold text-gray-400 uppercase mb-1">Modus</label>
                                <div class="flex items-center justify-center gap-2 w-full">
                                    <input type="number" id="mode-value" value="5" min="1" max="60" class="w-12 text-center text-2xl font-bold text-red-600 outline-none border-b border-gray-200 bg-transparent" onfocus="this.select()" onchange="updateModeValue(this.value)">
                                    <select id="mode-select" class="bg-transparent font-bold text-blue-600 outline-none text-sm touch-target text-left w-full" onchange="switchMode(this.value)">
                                        <option value="time">Minuten</option>
                                        <option value="count">WÃ¶rter</option>
                                    </select>
                                </div>
                            </div>
                        </div>
                        
                        <div class="toggle-grid">
                            <!-- GEÃ„NDERT: Texte angepasst -->
                            <label class="touch-target flex flex-col items-center justify-center gap-1 bg-white rounded-lg border border-gray-200 py-2 active:bg-gray-100 transition-colors">
                                <input id="silben-faerben" type="checkbox" checked class="h-4 w-4 text-blue-600 rounded pointer-events-none">
                                <span class="text-[10px] sm:text-xs font-bold text-gray-600 pointer-events-none text-center whitespace-nowrap">Rot-Blau-Silben</span>
                            </label>
                            <label class="touch-target flex flex-col items-center justify-center gap-1 bg-white rounded-lg border border-gray-200 py-2 active:bg-gray-100 transition-colors">
                                <input id="silben-abstand" type="checkbox" class="h-4 w-4 text-blue-600 rounded pointer-events-none">
                                <span class="text-[10px] sm:text-xs font-bold text-gray-600 pointer-events-none text-center whitespace-nowrap">Abstand zw. Silben</span>
                            </label>
                            <label class="touch-target flex flex-col items-center justify-center gap-1 bg-white rounded-lg border border-gray-200 py-2 active:bg-gray-100 transition-colors">
                                <input id="artikel-anzeigen" type="checkbox" class="h-4 w-4 text-blue-600 rounded pointer-events-none">
                                <span class="text-[10px] sm:text-xs font-bold text-gray-600 pointer-events-none text-center whitespace-nowrap">Nomen mit Artikeln</span>
                            </label>
                        </div>
                    </div>

                    <!-- Stufen Auswahl (3 Spalten Grid) -->
                    <div class="grid grid-cols-3 gap-2" id="heft-grid"></div>
                    
                    <!-- Buchstaben Auswahl im Flow -->
                    <div id="buchstaben-wrapper" class="p-3 bg-blue-50/50 rounded-xl border border-blue-100 mt-1">
                        <div class="flex justify-between items-center mb-2">
                            <span class="text-[10px] font-bold text-blue-800 uppercase">Buchstaben wÃ¤hlen:</span>
                            <button type="button" id="btn-select-all" class="touch-target text-[10px] text-blue-600 font-semibold underline px-2 py-1">Alle der Stufe</button>
                        </div>
                        <div id="buchstaben-list-inner" class="grid grid-cols-10 gap-1"></div>
                    </div>

                </div>
            </div>

            <!-- Sticky Footer -->
            <div class="bg-white border-t border-gray-100 safe-area-pb z-50 shadow-[0_-5px_15px_rgba(0,0,0,0.05)] p-4">
                <button id="start-button" class="touch-target w-full bg-blue-600 hover:bg-blue-700 text-white font-bold text-2xl py-3 rounded-xl shadow-lg active:scale-95 transition-transform">
                    Starten
                </button>
            </div>
        </div>

        <!-- 2. SPIELFELD -->
        <div id="spiel" class="hidden w-full h-full relative flex flex-col opacity-100">
            <div class="absolute top-0 left-0 right-0 p-4 flex justify-between items-center z-50 pointer-events-none">
                <div class="flex items-center gap-3 pointer-events-auto">
                    <button id="stop-button" class="touch-target hidden bg-gray-100 text-gray-600 hover:bg-gray-200 font-bold text-sm px-4 py-2 rounded-full shadow-sm border border-gray-200 transition-all active:scale-95 shrink-0">
                        <span class="flex items-center gap-1"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M6 18L18 6M6 6l12 12"></path></svg> Beenden</span>
                    </button>
                    <div id="fortschritt-anzeige" class="text-blue-600 font-mono font-bold text-xl bg-white/90 backdrop-blur px-4 py-1 rounded-full shadow-sm border border-gray-100 flex items-center select-none whitespace-nowrap">
                        <span id="fortschritt-text">1 / 10</span>
                    </div>
                    <div id="timer-display" class="text-blue-600 font-mono font-bold text-xl bg-white/90 backdrop-blur px-4 py-1 rounded-full shadow-sm border border-gray-100 flex items-center select-none whitespace-nowrap">00:00</div>
                </div>
                <button id="einstellungen-button" class="touch-target text-gray-400 hover:text-blue-600 bg-white/90 backdrop-blur p-3 rounded-full shadow-sm border border-gray-100 pointer-events-auto active:scale-90 transition-transform ml-2">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M4 6h16M4 12h16m-7 6h7"></path></svg>
                </button>
            </div>
            
            <div id="2d-canvas-container" class="absolute inset-0 z-0 w-full h-full"></div>

            <div class="absolute inset-0 z-30 flex items-center justify-center pointer-events-none p-4 pb-20">
                <div id="card-swipe-layer" class="w-full max-w-xs aspect-[3/2] pointer-events-auto cursor-grab active:cursor-grabbing touch-none select-none will-change-transform relative">
                    <div id="card-content-layer" class="w-full h-full bg-white rounded-3xl card-shadow border border-gray-200 flex items-center justify-center relative overflow-hidden bg-white select-none transition-colors duration-150">
                        <div id="wort-anzeige-container" class="w-full h-full flex flex-row items-center justify-center px-8 sm:px-12 py-4 relative z-10 pointer-events-none gap-2 sm:gap-4">
                            <span id="artikel-anzeige" class="hidden font-bold leading-none font-learning text-gray-800"></span>
                            <div id="wort-anzeige" class="font-bold whitespace-nowrap select-none text-gray-800 leading-none font-learning flex"></div>
                        </div>
                        <div id="card-overlay" class="absolute inset-0 z-20 flex items-center justify-center opacity-0 transition-opacity duration-150 bg-transparent pointer-events-none"></div>
                    </div>
                </div>
            </div>

            <div id="los-button-container" class="hidden absolute bottom-12 left-0 right-0 flex justify-center z-50 pointer-events-none">
                <button id="los-button" class="touch-target pointer-events-auto bg-blue-600 hover:bg-blue-700 text-white font-bold text-3xl py-3 px-12 rounded-full shadow-xl transition-transform duration-150 hover:scale-105 active:scale-95 animate-bounce">Los!</button>
            </div>
        </div>

        <!-- 3. AUSWERTUNG -->
        <div id="auswertung" class="hidden absolute inset-0 z-[60] bg-white flex flex-col justify-center items-center p-6 select-none opacity-0 transition-opacity duration-1000">
            <h2 id="auswertung-titel" class="text-4xl font-bold text-blue-600 mb-8 drop-shadow-sm font-learning text-center px-2">Super!</h2>
            <div id="tier-leiter" class="flex flex-row items-end justify-center gap-4 mb-8 w-full max-w-sm h-24"></div>
            <div id="result-box" class="bg-gray-50 p-6 rounded-2xl border border-gray-100 mb-8 w-full max-w-xs text-center shadow-sm"></div>
            <button id="zurueck-button" class="touch-target w-full max-w-xs bg-blue-600 hover:bg-blue-700 text-white font-bold text-2xl py-4 rounded-xl shadow-lg active:scale-95 transition-transform">Nochmal spielen</button>
        </div>
    </div>

    <script>
        // --- DATEN ---
        const HEFTE = [
            { name: "1", letters: "L, O, A, M, I, S, T", suffix: "", buchstaben: ['L', 'O', 'A', 'M', 'I', 'S', 'T'], min: 1, max: 2 },
            { name: "2", letters: "E, N, D, U, P, K", suffix: "(inkl. Stufe 1)", buchstaben: ['E', 'N', 'D', 'U', 'P', 'K'], min: 1, max: 3 },
            { name: "3", letters: "B, F, Ei, R, H, W", suffix: "(inkl. Stufe 1-2)", buchstaben: ['B', 'F', 'Ei', 'R', 'H', 'W'], min: 2, max: 3 },
            { name: "4", letters: "G, Au, Sch, ie, Z, Eu, Ch", suffix: "(inkl. Stufe 1-3)", buchstaben: ['G', 'Au', 'Sch', 'ie', 'Z', 'Eu', 'Ch'], min: 2, max: 4 },
            { name: "5", letters: "Sp, St, Ã„, Ã–, Ãœ, ng, Ã„u, V, J", suffix: "(inkl. Stufe 1-4)", buchstaben: ['Sp', 'St', 'Ã„', 'Ã–', 'Ãœ', 'ng', 'Ã„u', 'V', 'J'], min: 2, max: 4 },
            { name: "6", letters: "nk, ÃŸ, X, Y, C, ck, Qu", suffix: "(inkl. Stufe 1-5)", buchstaben: ['nk', 'ÃŸ', 'X', 'Y', 'C', 'ck', 'Qu'], min: 2, max: 4 }
        ];

        const ANIMALS = [
            { icon: 'ðŸŒ', wpm: 1, title: "GemÃ¼tlich wie eine Schnecke!" },
            { icon: 'ðŸ¢', wpm: 2, title: "Stetig wie eine SchildkrÃ¶te!" },
            { icon: 'ðŸ‡', wpm: 3, title: "HÃ¼pfig wie ein Hase!" },
            { icon: 'ðŸŽ', wpm: 4, title: "Schnell wie ein Pferd!" },
            { icon: 'ðŸ†', wpm: 5, title: "Pfeilschnell wie ein Gepard!" }
        ];

        const VOKALE_LISTE = ['A', 'E', 'I', 'O', 'U', 'Ã„', 'Ã–', 'Ãœ'];
        const DIPHTHONGE_LISTE = ['Ei', 'Ai', 'Eu', 'Au', 'ie', 'Ã„u'];
        const RAINBOW_COLORS = ['#9C4F96', '#FF6355', '#FBA949', '#FAE442', '#8BD448', '#2AA8F2'];
        
        // l: Level (1-6)
        const WOERTERBUCH = [
            // STUFE 1 (L,O,A,M,I,S,T)
            {l:1, s:['Ma','ma'], a:'die'}, {l:1, s:['Mi','mi'], a:'die'}, {l:1, s:['O','mi'], a:'die'}, {l:1, s:['O','ma'], a:'die'}, {l:1, s:['A','li'], a:'der'},
            {l:1, s:['Li','lo'], a:'die'}, {l:1, s:['Lo','la'], a:'die'}, {l:1, s:['Li','sa'], a:'die'}, {l:1, s:['Sis','si'], a:'die'}, {l:1, s:['Mo','mo'], a:'der'},
            {l:1, s:['La','ma'], a:'das'}, {l:1, s:['Li','la'], a:'das'}, {l:1, s:['Sa','la','mi'], a:'die'}, {l:1, s:['Li','mo'], a:'die'}, {l:1, s:['Si','lo'], a:'das'},
            {l:1, s:['So','lo'], a:'das'}, {l:1, s:['Mal'], a:'das'}, {l:1, s:['Los'], a:'das'}, {l:1, s:['Mi','mi','mi'], a:'das'},
            {l:1, s:['li','la']}, {l:1, s:['los']}, {l:1, s:['so','la','la']}, {l:1, s:['mal']}, {l:1, s:['soll']}, {l:1, s:['lass']}, {l:1, s:['So','ma','li','a']},
            {l:1, s:['Sa','lat'], a:'der'}, {l:1, s:['Ast'], a:'der'}, {l:1, s:['Mast'], a:'der'}, {l:1, s:['List'], a:'die'}, {l:1, s:['Tal'], a:'das'}, {l:1, s:['Tat'], a:'die'},
            {l:1, s:['ist']}, {l:1, s:['toll']}, {l:1, s:['satt']}, {l:1, s:['alt']},
            {l:1, s:['Im']}, {l:1, s:['Am']},

            // STUFE 2 (+E,N,D,U,P,K)
            {l:2, s:['Pan','da'], a:'der'}, {l:2, s:['En','te'], a:'die'}, {l:2, s:['Pu','del'], a:'der'}, {l:2, s:['Ka','mel'], a:'das'}, {l:2, s:['Pe','li','kan'], a:'der'},
            {l:2, s:['Lamm'], a:'das'}, {l:2, s:['Pu','te'], a:'die'}, {l:2, s:['An','ti','lo','pe'], a:'die'}, {l:2, s:['Ka','ka','du'], a:'der'},
            {l:2, s:['To','ma','te'], a:'die'}, {l:2, s:['Me','lo','ne'], a:'die'}, {l:2, s:['Ka','ka','o'], a:'der'}, {l:2, s:['Nu','del'], a:'die'}, {l:2, s:['A','na','nas'], a:'die'},
            {l:2, s:['Keks'], a:'der'}, {l:2, s:['Li','mo','na','de'], a:'die'}, {l:2, s:['Do','se'], a:'die'}, {l:2, s:['Mond'], a:'der'}, {l:2, s:['Son','ne'], a:'die'},
            {l:2, s:['Tas','se'], a:'die'}, {l:2, s:['Lu','pe'], a:'die'}, {l:2, s:['Pin','sel'], a:'der'}, {l:2, s:['Kis','te'], a:'die'}, {l:2, s:['Lam','pe'], a:'die'},
            {l:2, s:['Pa','ket'], a:'das'}, {l:2, s:['Post'], a:'die'}, {l:2, s:['Tan','ne'], a:'die'}, {l:2, s:['Sand'], a:'der'}, {l:2, s:['See'], a:'der'},
            {l:2, s:['Do','mi','no'], a:'das'}, {l:2, s:['Mi','ka','do'], a:'das'}, {l:2, s:['Pa','pa'], a:'der'}, {l:2, s:['Tan','te'], a:'die'}, {l:2, s:['On','kel'], a:'der'},
            {l:2, s:['Pi','lot'], a:'der'}, {l:2, s:['Kun','de'], a:'der'}, {l:2, s:['Pa','te'], a:'der'}, {l:2, s:['Mi','nu','ten'], a:'die'}, {l:2, s:['E','le','na'], a:'die'},
            {l:2, s:['nett']}, {l:2, s:['dumm']}, {l:2, s:['kalt']}, {l:2, s:['nass']}, {l:2, s:['laut']}, {l:2, s:['mun','ter']}, {l:2, s:['dan','kend']}, {l:2, s:['rund']}, {l:2, s:['e','del']},
            {l:2, s:['tun']}, {l:2, s:['tunkt']}, {l:2, s:['putzt']}, {l:2, s:['isst']}, {l:2, s:['sen','det']}, {l:2, s:['dehnt']}, {l:2, s:['en','det']}, {l:2, s:['kannst']}, {l:2, s:['ma','len']}, {l:2, s:['le','sen']}, {l:2, s:['tur','nen']}, {l:2, s:['sein']},
            {l:2, s:['tas','ten']}, {l:2, s:['tes','ten']}, {l:2, s:['kos','ten']}, {l:2, s:['pus','ten']}, {l:2, s:['kne','ten']},

            // STUFE 3 (+B,F,Ei,R,H,W)
            {l:3, s:['Eis'], a:'das'}, {l:3, s:['Sei','fe'], a:'die'}, {l:3, s:['Lei','ter'], a:'die'}, {l:3, s:['Rei','se'], a:'die'}, {l:3, s:['Rei','fen'], a:'der'}, {l:3, s:['Brei'], a:'der'},
            {l:3, s:['Hund'], a:'der'}, {l:3, s:['Wolf'], a:'der'}, {l:3, s:['Ro','se'], a:'die'}, {l:3, s:['Ho','se'], a:'die'}, {l:3, s:['Hut'], a:'der'}, {l:3, s:['Hof'], a:'der'},
            {l:3, s:['Fo','to'], a:'das'}, {l:3, s:['So','fa'], a:'das'}, {l:3, s:['E','le','fant'], a:'der'}, {l:3, s:['Fahr','rad'], a:'das'}, {l:3, s:['Win','ter'], a:'der'}, {l:3, s:['Was','ser'], a:'das'},
            {l:3, s:['Wurm'], a:'der'}, {l:3, s:['Tor'], a:'das'}, {l:3, s:['Ra','dio'], a:'das'}, {l:3, s:['Te','le','fon'], a:'das'}, {l:3, s:['Ta','fel'], a:'die'}, {l:3, s:['Fens','ter'], a:'das'},
            {l:3, s:['Leh','rer'], a:'der'}, {l:3, s:['Fah','rer'], a:'der'}, {l:3, s:['Far','be'], a:'die'}, {l:3, s:['Mar','me','la','de'], a:'die'}, {l:3, s:['Feu','er','wehr'], a:'die'}, {l:3, s:['In','di','a','ner'], a:'der'},
            {l:3, s:['Trom','pe','te'], a:'die'}, {l:3, s:['Pra','li','ne'], a:'die'}, {l:3, s:['Ball'], a:'der'}, {l:3, s:['Brot'], a:'das'}, {l:3, s:['Bein'], a:'das'}, {l:3, s:['Baum'], a:'der'},
            {l:3, s:['lei','se']}, {l:3, s:['teu','er']}, {l:3, s:['neu']}, {l:3, s:['froh']}, {l:3, s:['hart']}, {l:3, s:['wahr']}, {l:3, s:['hell']}, {l:3, s:['warm']}, {l:3, s:['rot']}, {l:3, s:['weit']}, {l:3, s:['frei']}, {l:3, s:['flau']}, {l:3, s:['treu']},
            {l:3, s:['reist']}, {l:3, s:['lÃ¤uft']}, {l:3, s:['weint']}, {l:3, s:['ruft']}, {l:3, s:['hÃ¶rt']}, {l:3, s:['haut']}, {l:3, s:['kauft']}, {l:3, s:['freut']}, {l:3, s:['hofft']}, {l:3, s:['wÃ¤rmt']}, {l:3, s:['wart']}, {l:3, s:['fah','re']}, {l:3, s:['ho','len']},
            {l:3, s:['ren','nen']}, {l:3, s:['ru','hen']}, {l:3, s:['ru','fen']}, {l:3, s:['rei','ten']}, {l:3, s:['lau','fen']}, {l:3, s:['kau','fen']}, {l:3, s:['tei','len']}, {l:3, s:['fei','ern']}, {l:3, s:['heu','len']}, {l:3, s:['woh','nen']}, {l:3, s:['fah','ren']}, {l:3, s:['wer','fen']}, {l:3, s:['war','ten']}, {l:3, s:['hus','ten']},

            // STUFE 4 (+G,Au,Sch,ie,Z,Eu,Ch)
            {l:4, s:['Maus'], a:'die'}, {l:4, s:['Haus'], a:'das'}, {l:4, s:['Au','to'], a:'das'}, {l:4, s:['Eu','le'], a:'die'}, {l:4, s:['Mau','er'], a:'die'}, {l:4, s:['Feu','er'], a:'das'}, {l:4, s:['Eu','ro'], a:'der'},
            {l:4, s:['A','mei','se'], a:'die'}, {l:4, s:['Fle','der','maus'], a:'die'}, {l:4, s:['Haus','tier'], a:'das'},
            {l:4, s:['Schu','le'], a:'die'}, {l:4, s:['Tisch'], a:'der'}, {l:4, s:['Fisch'], a:'der'}, {l:4, s:['Schiff'], a:'das'}, {l:4, s:['Schaf'], a:'das'}, {l:4, s:['Ta','sche'], a:'die'}, {l:4, s:['WÃ¤','sche'], a:'die'},
            {l:4, s:['Buch'], a:'das'}, {l:4, s:['Geld'], a:'das'}, {l:4, s:['Gold'], a:'das'}, {l:4, s:['Gras'], a:'das'}, {l:4, s:['Glas'], a:'das'}, {l:4, s:['Dach'], a:'das'}, {l:4, s:['Licht'], a:'das'}, {l:4, s:['Nacht'], a:'die'},
            {l:4, s:['Ge','mÃ¼','se'], a:'das'}, {l:4, s:['Bie','ne'], a:'die'}, {l:4, s:['Rie','se'], a:'der'}, {l:4, s:['Knie'], a:'das'}, {l:4, s:['Brief'], a:'der'}, {l:4, s:['Zeh'], a:'der'}, {l:4, s:['Zahn'], a:'der'}, {l:4, s:['Zelt'], a:'das'},
            {l:4, s:['ge','hen']}, {l:4, s:['ge','ben']}, {l:4, s:['sa','gen']}, {l:4, s:['sin','gen']}, {l:4, s:['lie','gen']}, {l:4, s:['ma','chen']}, {l:4, s:['su','chen']}, {l:4, s:['schla','fen']}, {l:4, s:['schrei','ben']}, {l:4, s:['schwim','men']},

            // STUFE 5 (+Sp,St,Ã„,Ã–,Ãœ,ng,Ã„u,V,J)
            {l:5, s:['Spin','ne'], a:'die'}, {l:5, s:['Sport'], a:'der'}, {l:5, s:['Spiel'], a:'das'}, {l:5, s:['Stern'], a:'der'}, {l:5, s:['Stein'], a:'der'}, {l:5, s:['Stadt'], a:'die'},
            {l:5, s:['BÃ¤r'], a:'der'}, {l:5, s:['KÃ¤','se'], a:'der'}, {l:5, s:['MÃ¤d','chen'], a:'das'}, {l:5, s:['Ã–l'], a:'das'}, {l:5, s:['LÃ¶','we'], a:'der'}, {l:5, s:['KÃ¶','nig'], a:'der'},
            {l:5, s:['TÃ¼r'], a:'die'}, {l:5, s:['MÃ¼ll'], a:'der'}, {l:5, s:['SchÃ¼','ler'], a:'der'}, {l:5, s:['Ãœ','bung'], a:'die'}, {l:5, s:['GlÃ¼ck'], a:'das'},
            {l:5, s:['Ring'], a:'der'}, {l:5, s:['Ding'], a:'das'}, {l:5, s:['Jun','ge'], a:'der'}, {l:5, s:['Zun','ge'], a:'die'},
            {l:5, s:['HÃ¤u','ser'], a:'die'}, {l:5, s:['MÃ¤u','se'], a:'die'}, {l:5, s:['LÃ¤u','se'], a:'die'},
            {l:5, s:['Vo','gel'], a:'der'}, {l:5, s:['Va','se'], a:'die'}, {l:5, s:['Va','ter'], a:'der'}, {l:5, s:['Vul','kan'], a:'der'},
            {l:5, s:['JÃ¤','ger'], a:'der'}, {l:5, s:['Ja','gu','ar'], a:'der'}, {l:5, s:['Jog','hurt'], a:'der'}, {l:5, s:['Ja','cke'], a:'die'},
            {l:5, s:['schÃ¶n']}, {l:5, s:['grÃ¼n']}, {l:5, s:['sÃ¼ÃŸ']}, {l:5, s:['jung']}, {l:5, s:['bÃ¶s']},
            {l:5, s:['sprin','gen']}, {l:5, s:['ste','hen']}, {l:5, s:['spie','len']}, {l:5, s:['Ã¼','ben']}, {l:5, s:['jagen']},

            // STUFE 6 (+nk,ÃŸ,X,Y,C,ck,Qu)
            {l:6, s:['Bank'], a:'die'}, {l:6, s:['Dank'], a:'der'}, {l:6, s:['Schrank'], a:'der'},
            {l:6, s:['FuÃŸ'], a:'der'}, {l:6, s:['Stra','ÃŸe'], a:'die'}, {l:6, s:['groÃŸ']}, {l:6, s:['sÃ¼ÃŸ']}, {l:6, s:['weiÃŸ']},
            {l:6, s:['Xy','lo','phon'], a:'das'}, {l:6, s:['Ta','xi'], a:'das'}, {l:6, s:['Text'], a:'der'},
            {l:6, s:['Po','ny'], a:'das'}, {l:6, s:['Han','dy'], a:'das'}, {l:6, s:['Yog','hurt'], a:'der'},
            {l:6, s:['Com','pu','ter'], a:'der'}, {l:6, s:['Clown'], a:'der'}, {l:6, s:['Cam','ping'], a:'das'},
            {l:6, s:['Sack'], a:'der'}, {l:6, s:['Da','ckel'], a:'der'}, {l:6, s:['We','cker'], a:'der'}, {l:6, s:['So','cken'], a:'die'}, {l:6, s:['RÃ¼','cken'], a:'der'}, {l:6, s:['BÃ¤','cker'], a:'der'}, {l:6, s:['Schne','cke'], a:'die'},
            {l:6, s:['Qual','le'], a:'die'}, {l:6, s:['Quel','le'], a:'die'}, {l:6, s:['Quark'], a:'der'}, {l:6, s:['A','qua','ri','um'], a:'das'}, {l:6, s:['quaken']}, {l:6, s:['quer']},
            {l:6, s:['ba','cken']}, {l:6, s:['pa','cken']}, {l:6, s:['kochen']}, {l:6, s:['la','chen']}
        ];

        // --- STATE ---
        const state = {
            settings: { 
                heftIndex: 0, 
                buchstaben: [], 
                minSilben: 1, 
                maxSilben: 2, 
                mode: 'time', 
                targetCount: 10,
                targetTime: 5,
                farben: true, 
                abstand: false, 
                showArticles: false, 
                currentLetters: [], 
                manualSyllables: false 
            },
            game: { runde: 0, richtig: 0, history: new Set(), colorIndex: 0, active: false, finished: false, inBonusPhase: false, letterStats: {}, wordStartTime: 0, startTimeGlobal: 0, timerInterval: null, realWordsPossible: [], isProcessing: false, finalDuration: 0, isVortexing: false },
            view: { zoom: 1, targetZoom: 1 }
        };

        // --- DOM ---
        const dom = {
            intro: document.getElementById('intro-screen'), app: document.getElementById('app'),
            views: { start: document.getElementById('startbildschirm'), spiel: document.getElementById('spiel'), ende: document.getElementById('auswertung'), titleEnd: document.getElementById('auswertung-titel') },
            inputs: { 
                heftGrid: document.getElementById('heft-grid'), 
                buchstabenWrapper: document.getElementById('buchstaben-wrapper'),
                buchstabenList: document.getElementById('buchstaben-list-inner'),
                min: document.getElementById('min-silben'), max: document.getElementById('max-silben'), 
                modeValue: document.getElementById('mode-value'),
                modeSelect: document.getElementById('mode-select'),
                color: document.getElementById('silben-faerben'), gap: document.getElementById('silben-abstand'), 
                artikel: document.getElementById('artikel-anzeigen'),
                btnSelectAll: document.getElementById('btn-select-all')
            },
            btns: { start: document.getElementById('start-button'), settings: document.getElementById('einstellungen-button'), back: document.getElementById('zurueck-button'), stop: document.getElementById('stop-button'), los: document.getElementById('los-button') },
            card: { swipe: document.getElementById('card-swipe-layer'), content: document.getElementById('card-content-layer'), textContainer: document.getElementById('wort-anzeige-container'), text: document.getElementById('wort-anzeige'), artikel: document.getElementById('artikel-anzeige'), overlay: document.getElementById('card-overlay'), bg: document.getElementById('swipe-feedback-bg') },
            stats: { progressText: document.getElementById('fortschritt-text'), timer: document.getElementById('timer-display'), animals: document.getElementById('tier-leiter'), resultBox: document.getElementById('result-box') },
            misc: { losContainer: document.getElementById('los-button-container') },
            toast: { el: document.getElementById('game-toast'), text: document.getElementById('game-toast-text') },
            dictionary: { overlay: document.getElementById('dictionary-overlay'), content: document.getElementById('dictionary-content') }
        };

        let engine, render, runner, stirrer, mouseConstraint, physicsActive = false;

        document.addEventListener('DOMContentLoaded', () => {
            // FONT LOADING CHECK
            document.fonts.ready.then(() => {
                const title = document.getElementById('intro-title');
                if(title) title.classList.remove('opacity-0');
            });

            try {
                initHeftList();
                
                dom.btns.start.onclick = startGame;
                dom.btns.settings.onclick = showStart;
                dom.btns.back.onclick = showStart;
                dom.btns.los.onclick = startVortex;
                
                if(dom.inputs.btnSelectAll) dom.inputs.btnSelectAll.onclick = selectAllChars;
                
                dom.btns.stop.onclick = handleStopButton;
                window.addEventListener('resize', () => { if(physicsActive) resizePhysics(); adjustFontSize(); });
                // --- GEÃ„NDERT: Touch events fÃ¼r Stirrer hinzugefÃ¼gt ---
                document.addEventListener('mousemove', moveStirrer);
                document.addEventListener('touchmove', moveStirrer, {passive: false});
                document.addEventListener('touchstart', handleInteractionStart, {passive: false});
                document.addEventListener('mousedown', handleInteractionStart);
                document.addEventListener('touchend', endStirrer);
                document.addEventListener('mouseup', endStirrer);
                
                initSwipeLogic();
                ladeEinstellungen();
                startAppSequence();
                
            } catch (e) {
                console.error(e);
                dom.intro.style.display = 'none'; dom.app.classList.remove('hidden'); dom.app.style.opacity = '1'; dom.views.start.classList.remove('hidden'); dom.views.start.classList.add('flex');
            }
        });

        // --- DICTIONARY FEATURE ---
        function toggleDictionary(show) {
            if(show) {
                dom.dictionary.content.innerHTML = '';
                // Render Dictionary
                HEFTE.forEach((heft, i) => {
                    const levelWords = WOERTERBUCH.filter(w => w.l === (i + 1));
                    if(levelWords.length === 0) return;

                    const section = document.createElement('div');
                    section.innerHTML = `<h3 class="text-xl font-bold text-blue-600 mb-2 mt-4 font-learning border-b border-blue-100">Stufe ${heft.name}</h3>`;
                    
                    const grid = document.createElement('div');
                    grid.className = 'grid grid-cols-2 gap-2 sm:grid-cols-3';
                    
                    levelWords.forEach(w => {
                        const div = document.createElement('div');
                        div.className = 'flex items-center gap-1 p-2 bg-white rounded shadow-sm border border-gray-100 text-sm';
                        
                        if(w.a) {
                            const art = document.createElement('span');
                            art.textContent = w.a.toLowerCase();
                            art.className = 'text-gray-400 font-learning text-xs';
                            div.appendChild(art);
                        }
                        
                        const wordSpan = document.createElement('span');
                        wordSpan.className = 'font-bold text-gray-800 font-learning';
                        
                        // Silben fÃ¤rben im WÃ¶rterbuch
                        w.s.forEach((silbe, idx) => {
                            const sSpan = document.createElement('span');
                            let txt = silbe.toLowerCase();
                            if(idx === 0) txt = txt.charAt(0).toUpperCase() + txt.slice(1);
                            sSpan.textContent = txt;
                            sSpan.className = idx % 2 === 0 ? 'text-blue-600' : 'text-red-600';
                            wordSpan.appendChild(sSpan);
                        });
                        
                        div.appendChild(wordSpan);
                        grid.appendChild(div);
                    });
                    
                    section.appendChild(grid);
                    dom.dictionary.content.appendChild(section);
                });
                
                dom.dictionary.overlay.classList.remove('hidden');
                dom.dictionary.overlay.classList.add('flex');
            } else {
                dom.dictionary.overlay.classList.add('hidden');
                dom.dictionary.overlay.classList.remove('flex');
            }
        }

        // --- HINWEIS (TOAST) ---
        function showOverlayMessage(msg) {
            if(!dom.toast.el) return;
            dom.toast.text.textContent = msg;
            dom.toast.el.classList.remove('opacity-0', 'scale-95');
            setTimeout(() => {
                dom.toast.el.classList.add('opacity-0', 'scale-95');
            }, 3000);
        }

        // DEFINIERE DIESE FUNKTIONEN ZUERST
        function showEnd() {
            state.game.active = false; stopPhysics();
            dom.views.spiel.classList.add('hidden'); 
            // Weicher Ãœbergang
            dom.views.spiel.style.opacity = '0';
            
            setTimeout(() => {
                 dom.views.spiel.classList.add('hidden');
                 dom.views.ende.classList.remove('hidden'); 
                 dom.views.ende.classList.add('flex');
                 
                 // Fade In End Screen
                 requestAnimationFrame(() => {
                     dom.views.ende.classList.remove('opacity-0');
                 });
            }, 1000);
            
            const dur = state.game.finalDuration || (Date.now() - state.game.startTimeGlobal);
            const secs = Math.floor(dur/1000);
            const formattedTime = `${Math.floor(secs/60).toString().padStart(2,'0')}:${(secs%60).toString().padStart(2,'0')}`;

            const mins = secs/60; const wpm = mins > 0 ? state.game.richtig / mins : 0;
            let level = -1; 
            ANIMALS.forEach((a, i) => { if(wpm >= a.wpm) level = i; });
            
            dom.views.titleEnd.textContent = level >= 0 ? ANIMALS[level].title : "Gut gemacht!";

            // ANIMALS RENDER
            dom.stats.animals.innerHTML = ANIMALS.map((a, i) => `
                <div class="flex flex-col items-center justify-center transition-all duration-500 ${i===level ? 'animal-active' : 'animal-icon'}">
                    <span class="text-5xl">${a.icon}</span>
                </div>
            `).join(''); 

            // RESULT TEXT UPDATE - MIT SCHRIFTGRÃ–ÃŸEN ANPASSUNG
            if (state.settings.mode === 'count') {
                const wortLabel = state.game.richtig === 1 ? "Wort" : "WÃ¶rter";
                dom.stats.resultBox.innerHTML = `
                    <p class="text-3xl font-bold text-gray-800 mb-4">Du hast <span class="text-blue-600 text-4xl">${state.game.richtig}</span> ${wortLabel} gelesen!</p>
                    <p class="text-lg text-gray-500">Du hast dafÃ¼r <span class="font-mono text-gray-800 font-bold">${formattedTime}</span> Minuten gebraucht.</p>
                `;
            } else {
                const wortLabel = state.game.richtig === 1 ? "Wort" : "WÃ¶rter";
                dom.stats.resultBox.innerHTML = `
                    <p class="text-gray-500 text-base mb-2">Ergebnis</p>
                    <p class="text-4xl font-bold text-gray-800 mb-2"><span class="text-green-600">${state.game.richtig}</span> ${wortLabel}</p>
                    <p class="text-lg text-gray-500">Zeit: <span class="font-mono text-gray-700">${formattedTime}</span></p>
                `;
            }
        }

        // --- STRUDEL FUNKTION ---
        function startVortex() {
            state.game.isVortexing = true;
            dom.misc.losContainer.classList.add('hidden'); // Button verstecken
            
            if(engine) {
                // Schwerkraft aus
                engine.world.gravity.y = 0; 
                
                // Wirbel-Schleife
                let startV = Date.now();
                
                function updateVortex() {
                    if(!state.game.isVortexing || !engine || !render) return;
                    
                    let elapsed = Date.now() - startV;
                    // 4 Sekunden
                    if(elapsed > 4000) {
                        showEnd();
                        return;
                    }
                    
                    const bodies = Matter.Composite.allBodies(engine.world).filter(b => !b.isStatic && b.label !== 'wall');
                    const cx = render.canvas.width / 2;
                    const cy = render.canvas.height / 2;
                    
                    bodies.forEach(b => {
                        const dx = cx - b.position.x;
                        const dy = cy - b.position.y;
                        
                        // Startet NOCH langsamer (0.0000002)
                        const pullStrength = 0.0000005 * (1 + elapsed/3000); 
                        const turnStrength = 0.00001 * (1 + elapsed/4000);
                        
                        // DÃ¤mpfung
                        Matter.Body.setVelocity(b, {
                            x: b.velocity.x * 0.98,
                            y: b.velocity.y * 0.98
                        });

                        Matter.Body.applyForce(b, b.position, {
                            x: dx * pullStrength + dy * turnStrength, // Sog + Rotation
                            y: dy * pullStrength - dx * turnStrength
                        });
                    });
                    
                    requestAnimationFrame(updateVortex);
                }
                updateVortex();
            }
        }

        // --- MENÃœ: GRID BUTTONS ---
        function initHeftList() {
            dom.inputs.heftGrid.innerHTML = HEFTE.map((h, i) => `
                <button class="heft-btn touch-target flex flex-col items-center justify-center p-3 rounded-xl border-2 transition-all duration-200 shadow-sm bg-white hover:bg-gray-50 active:scale-95 min-h-[5rem]" onclick="selectHeft(${i})">
                    <span class="font-bold text-gray-800 text-xl">Stufe ${h.name}</span>
                    ${h.suffix ? `<span class="text-[10px] text-gray-400 mt-1">${h.suffix}</span>` : ''}
                </button>
            `).join('');
        }

        function selectHeft(index) {
            state.settings.heftIndex = index;
            
            // Auto-Silben
            if (!state.settings.manualSyllables) {
                const conf = HEFTE[index];
                dom.inputs.min.value = conf.min;
                dom.inputs.max.value = conf.max;
            }

            // Visual Update Buttons
            const buttons = dom.inputs.heftGrid.querySelectorAll('.heft-btn');
            buttons.forEach((btn, i) => {
                btn.className = 'heft-btn touch-target flex flex-col items-center justify-center p-3 rounded-xl border-2 transition-all duration-200 shadow-sm min-h-[5rem] active:scale-95';
                
                if (i === index) {
                    btn.classList.add('border-blue-600', 'bg-blue-50', 'shadow-md', 'ring-1', 'ring-blue-200');
                    // Text colors active
                    btn.querySelector('span:first-child').classList.replace('text-gray-800', 'text-blue-700');
                } else {
                    btn.classList.add('border-gray-200', 'bg-white', 'text-gray-400');
                    btn.querySelector('span:first-child').classList.add('text-gray-800');
                }
            });

            updateBuchstabenUI(index);
        }

        // GEÃ„NDERT: Button wÃ¤hlt nur Buchstaben der gewÃ¤hlten Stufe (+ darunter)
        function updateBuchstabenUI(idx, savedSelection = null) {
            // Sammle alle Buchstaben aus allen Heften (eindeutig)
            let allLetters = [];
            HEFTE.forEach(heft => {
                heft.buchstaben.forEach(b => {
                    if (!allLetters.includes(b)) allLetters.push(b);
                });
            });

            // Bestimme, welche Buchstaben basierend auf der aktuellen Stufe (idx) standardmÃ¤ÃŸig aktiv sind
            let activeLettersInStufe = [];
            for (let i = 0; i <= idx; i++) {
                activeLettersInStufe = activeLettersInStufe.concat(HEFTE[i].buchstaben);
            }

            if(dom.inputs.buchstabenList) {
                dom.inputs.buchstabenList.innerHTML = allLetters.map(b => {
                    // Check if checked: either from savedSelection OR (if null) from current Stufe logic
                    let isChecked = false;
                    if (savedSelection) {
                        isChecked = savedSelection.includes(b);
                    } else {
                        isChecked = activeLettersInStufe.includes(b);
                    }

                    return `<div class="flex items-center justify-center"><input type="checkbox" id="cb-${b}" value="${b}" class="peer hidden" ${isChecked ? 'checked' : ''} onchange="saveSettings()"><label for="cb-${b}" class="touch-target w-full text-center py-1 border-2 border-gray-200 rounded-lg cursor-pointer text-gray-600 font-bold select-none transition-all peer-checked:border-blue-600 peer-checked:bg-white peer-checked:text-blue-700 peer-checked:shadow-sm text-sm bg-white active:scale-95 font-learning">${b}</label></div>`;
                }).join('');
            }
        }

        function selectAllChars() {
             const listInner = dom.inputs.buchstabenList;
             if(listInner) {
                 // GEÃ„NDERT: WÃ¤hlt nur Buchstaben aus, die zur aktuellen Stufe (und darunter) gehÃ¶ren.
                 // Wir mÃ¼ssen wissen, welche das sind.
                 let activeLettersInStufe = [];
                 for (let i = 0; i <= state.settings.heftIndex; i++) {
                     activeLettersInStufe = activeLettersInStufe.concat(HEFTE[i].buchstaben);
                 }
                 
                 const inputs = listInner.querySelectorAll('input');
                 inputs.forEach(cb => {
                     if (activeLettersInStufe.includes(cb.value)) {
                         cb.checked = true;
                     } else {
                         cb.checked = false; // ABWÃ„HLEN wenn nicht in Stufe
                     }
                 });
                 saveSettings();
             }
        }

        // --- NEW MODE HANDLING ---
        function switchMode(newMode) {
            state.settings.mode = newMode;
            // Update input value based on stored targets
            dom.inputs.modeValue.value = newMode === 'count' ? state.settings.targetCount : state.settings.targetTime;
            saveSettings();
        }

        function updateModeValue(val) {
            val = parseInt(val);
            if(state.settings.mode === 'count') state.settings.targetCount = val;
            else state.settings.targetTime = val;
            saveSettings();
        }

        function getAllAllowedLetters() {
            // Now we just read from the checkboxes directly, as they cover all possibilities
            const listInner = dom.inputs.buchstabenList;
            if(listInner) {
                 const checked = Array.from(listInner.querySelectorAll('input:checked')).map(c => c.value);
                 return checked;
            }
            // Fallback (should not happen if UI is rendered)
            return [];
        }

        function startAppSequence() {
            setTimeout(() => {
                dom.intro.classList.add('fade-out');
                setTimeout(() => { dom.intro.style.display = 'none'; dom.app.classList.remove('hidden'); void dom.app.offsetWidth; dom.app.style.opacity = '1'; dom.views.start.classList.remove('hidden'); dom.views.start.classList.add('flex'); }, 500);
            }, 1500);
        }

        function handleStopButton() {
            if (state.game.finished) { showEnd(); return; }
            if (state.game.inBonusPhase) { showEnd(); return; }

            if (dom.btns.stop.classList.contains('confirm-mode')) endGameTimeUp();
            else {
                dom.btns.stop.classList.add('confirm-mode', 'bg-red-600', 'text-white', 'border-red-600'); dom.btns.stop.innerHTML = 'Sicher?';
                setTimeout(() => { 
                    if(state.game.inBonusPhase) return;
                    dom.btns.stop.classList.remove('confirm-mode', 'bg-red-600', 'text-white', 'border-red-600'); 
                    dom.btns.stop.innerHTML = '<span class="flex items-center gap-1"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M6 18L18 6M6 6l12 12"></path></svg> Beenden</span>'; 
                }, 3000);
            }
        }

        // --- GAME LOOP ---
        function startGame() {
            saveSettings();
            
            const allowed = getAllAllowedLetters();
            if (allowed.length === 0) {
                 // Fallback: Current Heft letters
                 state.settings.currentLetters = HEFTE[state.settings.heftIndex].buchstaben;
            } else {
                 state.settings.currentLetters = allowed;
            }

            // GET TARGET BASED ON MODE
            const targetVal = state.settings.mode === 'count' ? state.settings.targetCount : state.settings.targetTime;

            state.game = { runde: 0, richtig: 0, history: new Set(), colorIndex: 0, active: true, finished: false, inBonusPhase: false, letterStats: {}, wordStartTime: 0, startTimeGlobal: Date.now(), timerInterval: null, realWordsPossible: [], isProcessing: false, finalDuration: 0, isVortexing: false };
            state.settings.currentLetters.forEach(b => state.game.letterStats[b] = 0);
            state.view = { zoom: 1, targetZoom: 1 };
            calcPossibleRealWords();
            
            // RESET Opacity
            dom.views.spiel.style.opacity = '1';
            dom.views.ende.classList.add('opacity-0');
            dom.views.ende.classList.add('hidden');

            dom.views.start.classList.add('hidden'); dom.views.start.classList.remove('flex');
            dom.views.ende.classList.add('hidden'); dom.views.ende.classList.remove('flex');
            dom.views.spiel.classList.remove('hidden'); dom.views.spiel.classList.add('flex');
            dom.card.swipe.classList.remove('hidden');
            dom.misc.losContainer.classList.add('hidden');
            
            // Reset Card
            dom.card.swipe.style.transition = 'none'; dom.card.swipe.style.transform = 'scale(1)'; dom.card.swipe.style.opacity = '1'; dom.card.content.classList.remove('animate-pop-in'); dom.card.overlay.style.opacity = '0';

            // Reset Button Style
            const btn = dom.btns.stop;
            btn.innerHTML = '<span class="flex items-center gap-1"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M6 18L18 6M6 6l12 12"></path></svg> Beenden</span>';
            btn.className = 'touch-target hidden bg-gray-100 text-gray-600 hover:bg-gray-200 font-bold text-sm px-4 py-2 rounded-full shadow-sm border border-gray-200 transition-all active:scale-95 shrink-0';

            if(state.settings.mode === 'time') {
                dom.btns.stop.classList.remove('hidden');
                dom.stats.progressText.parentElement.classList.remove('hidden');
                dom.stats.progressText.textContent = "0 WÃ¶rter";
            } else {
                dom.btns.stop.classList.add('hidden');
                dom.stats.progressText.parentElement.classList.remove('hidden');
            }
            
            if (state.game.timerInterval) clearInterval(state.game.timerInterval);
            state.game.timerInterval = setInterval(updateTimer, 1000);
            updateTimer();

            startPhysics();
            setTimeout(() => nextCard(true), 50);

            // SHOW TOAST AT START
            showOverlayMessage("Richtig gelesene WÃ¶rter nach rechts wischen.");
        }

        // GEÃ„NDERT: Level Filter & Manual Selection Logic
        function calcPossibleRealWords() {
             const allowedCharsFlat = new Set();
             state.settings.currentLetters.forEach(token => token.toUpperCase().split('').forEach(char => allowedCharsFlat.add(char)));
             
             state.game.realWordsPossible = WOERTERBUCH.filter(silben => {
                // 1. Check Chars
                if (!silben.s.join('').toUpperCase().split('').every(c => allowedCharsFlat.has(c))) return false;

                // 2. Check Level (Hard constraint from DB)
                // GEÃ„NDERT: Logik vereinfacht. Wenn ein Wort aus Level X ist, darf es nur kommen,
                // wenn wir Buchstaben/Hefte ausgewÃ¤hlt haben, die mindestens bis Level X reichen.
                // Aber: Wir haben "currentLetters" als Liste von erlaubten Buchstaben.
                // Wir ermitteln das MAXIMALE Level, aus dem Buchstaben gewÃ¤hlt wurden.
                // Beispiel: "Ei" ist Level 3. Wenn "Ei" gewÃ¤hlt ist, ist maxLevel >= 3.
                
                let maxAllowedLevel = 0;
                // Alle gewÃ¤hlten Buchstaben durchgehen
                state.settings.currentLetters.forEach(tok => {
                    // In welchem Heft kommt dieser Buchstabe vor?
                    HEFTE.forEach((h, idx) => {
                        // Ein Buchstabe kann in mehreren Heften "vorkommen" (theoretisch, hier aber unique per Stufe definiert in HEFTE array)
                        // ABER: In HEFTE sind sie unique pro Stufe definiert.
                        if (h.buchstaben.includes(tok)) {
                            if ((idx + 1) > maxAllowedLevel) maxAllowedLevel = idx + 1;
                        }
                    });
                });
                
                // Wort Level muss <= dem hÃ¶chsten Level der ausgewÃ¤hlten Buchstaben sein.
                if (silben.l > maxAllowedLevel) return false;

                // 3. Length check
                if(silben.s.length < state.settings.minSilben || silben.s.length > state.settings.maxSilben) return false;
                
                return true;
             });
        }

        function updateTimer() {
            const now = Date.now();
            let diff = 0;
            const targetVal = state.settings.mode === 'count' ? state.settings.targetCount : state.settings.targetTime;

            if (state.settings.mode === 'count') diff = now - state.game.startTimeGlobal;
            else {
                const endTime = state.game.startTimeGlobal + (targetVal * 60 * 1000);
                diff = endTime - now;
                if (diff <= 0) { diff = 0; endGameTimeUp(); return; }
            }
            const sec = Math.floor(diff / 1000);
            dom.stats.timer.textContent = `${Math.floor(sec/60).toString().padStart(2,'0')}:${(sec%60).toString().padStart(2,'0')}`;
            if (state.settings.mode === 'count') {
                const current = Math.min(state.game.runde + 1, targetVal);
                dom.stats.progressText.textContent = `Wort ${current} / ${targetVal}`;
            } else {
                dom.stats.progressText.textContent = `${state.game.runde} WÃ¶rter`;
            }
        }

        function showStart() {
            state.game.active = false;
            if (state.game.timerInterval) clearInterval(state.game.timerInterval);
            stopPhysics();
            dom.views.spiel.classList.add('hidden'); dom.views.ende.classList.add('hidden');
            dom.views.start.classList.remove('hidden'); dom.views.start.classList.add('flex');
            dom.card.content.style.backgroundColor = 'white';
        }

        function endGameTimeUp() {
            if (state.game.finished) return;
            if (state.game.timerInterval) clearInterval(state.game.timerInterval);
            
            // Setze Dauer fÃ¼r Zeitmodus
            state.game.finalDuration = state.settings.targetTime * 60 * 1000;
            
            state.game.finished = true;
            state.game.inBonusPhase = true;
            dom.card.swipe.classList.add('hidden');
            
            // Button Update
            const btn = dom.btns.stop;
            btn.classList.remove('hidden'); 
            btn.innerHTML = 'Zum Resultat';
            btn.className = 'touch-target bg-green-100 text-green-700 font-bold text-sm px-4 py-2 rounded-full shadow-sm border border-green-200 transition-all active:scale-95 shrink-0 animate-pulse';

            // --- Ã„NDERUNG: KEIN WIRBEL IM ZEITMODUS ---
            // Stattdessen Physik wach machen fÃ¼r manuelles Platzen
            if(world) Matter.Composite.allBodies(world).forEach(b => { 
                Matter.Sleeping.set(b, false); 
                b.sleepThreshold = -1; 
            });

            // TOAST MESSAGE TIME MODE
            showOverlayMessage("Tippe die Kugeln an! ðŸ‘");
        }

        // --- Endphase vorbereiten (WÃ¶rter Modus) ---
        function prepareEndPhase() {
            if (state.game.timerInterval) clearInterval(state.game.timerInterval);
            
            dom.card.swipe.classList.add('hidden');
            dom.misc.losContainer.classList.remove('hidden'); // LOS BUTTON ANZEIGEN
            
            // Stats
            state.game.finished = true;
            state.game.inBonusPhase = true;
            state.game.finalDuration = Date.now() - state.game.startTimeGlobal;
            dom.stats.progressText.textContent = "Fertig!";

            // Physics wach halten
            if(world) Matter.Composite.allBodies(world).forEach(b => { 
                Matter.Sleeping.set(b, false); 
                b.sleepThreshold = -1; 
            });

            // TOAST MESSAGE COUNT MODE
            showOverlayMessage(`Alle ${state.settings.targetCount} WÃ¶rter gelesen! ðŸ‘`);
        }

        function nextCard() {
            if (state.settings.mode === 'count' && state.game.runde >= state.settings.targetCount) { 
                prepareEndPhase(); 
                return; 
            }
            if (state.settings.mode === 'time' && state.game.finished) return;

            updateTimer(); 

            let wortObj = selectWordWithRules();
            // Fallback object structure
            if (!wortObj || !wortObj.s) { 
                // Fantasy word fallback
                wortObj = { s: generateFantasyWord(determineTargetLength()), a: null };
            }

            // Check history
            let versuche = 0;
            while (state.game.history.has(wortObj.s.join('')) && versuche < 30) { 
                let cand = selectWordWithRules();
                if(cand && cand.s) wortObj = cand;
                else wortObj = { s: generateFantasyWord(determineTargetLength()), a: null };
                versuche++; 
            }
            state.game.history.add(wortObj.s.join(''));
            
            const fullString = wortObj.s.join('').toUpperCase();
            state.settings.currentLetters.forEach(token => {
                if (fullString.includes(token.toUpperCase())) state.game.letterStats[token] = (state.game.letterStats[token] || 0) + 1;
            });

            // ARTIKEL ANZEIGE
            if (state.settings.showArticles && wortObj.a) {
                // GEÃ„NDERT: Artikel kleingeschrieben lassen
                const articleText = wortObj.a.toLowerCase();
                dom.card.artikel.textContent = articleText;
                dom.card.artikel.classList.remove('hidden');
                
                // GEÃ„NDERT: Klassen zurÃ¼cksetzen und Farbe setzen
                dom.card.artikel.className = 'font-bold leading-none font-learning mr-2 sm:mr-3'; 
                
                if (state.settings.farben) {
                    dom.card.artikel.classList.add('text-blue-600');
                } else {
                    dom.card.artikel.classList.add('text-gray-800');
                }
                
            } else {
                dom.card.artikel.textContent = '';
                dom.card.artikel.classList.add('hidden');
            }

            dom.card.text.innerHTML = '';
            wortObj.s.forEach((silbe, i) => {
                const span = document.createElement('span');
                let text = silbe.toLowerCase();
                // GroÃŸschreibung am Anfang des Wortes (Nomen)
                if (i === 0) text = text.charAt(0).toUpperCase() + text.slice(1);
                span.textContent = text;
                
                if (state.settings.farben) span.className = i % 2 === 0 ? 'text-blue-600' : 'text-red-600';
                
                if (state.settings.abstand && i < wortObj.s.length - 1) span.style.marginRight = '0.2em';
                
                dom.card.text.appendChild(span);
            });
            adjustFontSize();

            const card = dom.card.swipe;
            card.style.transition = 'none';
            card.style.transform = 'translate(0,0) rotate(0) scale(0.8)';
            card.style.opacity = '0';
            dom.card.overlay.style.opacity = '0';
            dom.card.content.style.backgroundColor = 'white';
            
            requestAnimationFrame(() => {
                card.style.transition = 'all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275)';
                card.style.transform = 'translate(0,0) rotate(0) scale(1)';
                card.style.opacity = '1';
                state.game.wordStartTime = Date.now();
                state.game.isProcessing = false;
            });
        }

        function selectWordWithRules() {
            // New Condition: No fantasy words for Heft 4 (Index 3)
            if (state.settings.heftIndex === 3) {
                 const unusedReal = state.game.realWordsPossible.filter(item => !state.game.history.has(item.s.join('')));
                 if (unusedReal.length > 0) return unusedReal[Math.floor(Math.random() * unusedReal.length)];
                 
                 // If all used, pick any real word (fallback)
                 if (state.game.realWordsPossible.length > 0) {
                     return state.game.realWordsPossible[Math.floor(Math.random() * state.game.realWordsPossible.length)];
                 }
                 // Absolute fallback
                 return { s: generateFantasyWord(determineTargetLength()), a: null };
            }

            const availableRealWords = state.game.realWordsPossible.length;
            const playedCount = state.game.runde + 1;
            
            // GEÃ„NDERT: Mehr FantasiewÃ¶rter in Stufe 2 (30%)
            const fantasyChance = (state.settings.heftIndex === 1) ? 0.3 : 0.05; // Stufe 2 = Index 1
            if (Math.random() < fantasyChance || (availableRealWords < 20 && playedCount % 3 === 0)) {
                 return { s: generateFantasyWord(determineTargetLength()), a: null };
            }
            
            const unusedReal = state.game.realWordsPossible.filter(item => !state.game.history.has(item.s.join('')));
            if (unusedReal.length > 0) return unusedReal[Math.floor(Math.random() * unusedReal.length)];
            
            // Fallback real word if no unused left
            if (state.game.realWordsPossible.length > 0) {
                 return state.game.realWordsPossible[Math.floor(Math.random() * state.game.realWordsPossible.length)];
            }
            
            return { s: generateFantasyWord(determineTargetLength()), a: null };
        }

        function determineTargetLength() {
            const min = state.settings.minSilben; const max = state.settings.maxSilben;
            if (min === max) return max;
            return Math.random() < 0.75 ? max : Math.floor(Math.random() * (max - 1 - min + 1)) + min;
        }

        function generateFantasyWord(length) {
            const v = state.settings.currentLetters.filter(b => VOKALE_LISTE.includes(b));
            const k = state.settings.currentLetters.filter(b => !VOKALE_LISTE.includes(b) && !DIPHTHONGE_LISTE.includes(b));
            const d = state.settings.currentLetters.filter(b => DIPHTHONGE_LISTE.includes(b));
            if (v.length === 0 && d.length === 0) return ["A".repeat(length).split('')]; 
            
            const pick = (pool) => {
                if (pool.length === 0) return '';
                let minU = Infinity; pool.forEach(c => { if((state.game.letterStats[c]||0)<minU) minU=state.game.letterStats[c]||0; });
                const cands = pool.filter(c => (state.game.letterStats[c]||0)===minU);
                return cands[Math.floor(Math.random()*cands.length)];
            };
            
            const res = [];
            let lastVowel = null;

            for(let i=0; i<length; i++) {
                let s='', type='KV', attempts=0, valid=false;
                do {
                    if(Math.random()<0.1) type='V'; else type='KV';
                    s='';
                    if(type==='KV' && k.length>0) s += pick(k);
                    if(d.length>0 && Math.random()<0.2) s += pick(d); else if(v.length>0) s += pick(v);
                    
                    const currentVowel = s.split('').find(char => VOKALE_LISTE.includes(char) || DIPHTHONGE_LISTE.includes(char));

                    valid = true;
                    if(i>0 && s===res[i-1]) valid=false;
                    if(i>0 && currentVowel && lastVowel && currentVowel === lastVowel && Math.random() < 0.8) valid=false;
                    if(length>=4 && i>1 && s===res[i-2]) valid=false;
                    if(i>0 && res[i-1].slice(-1).toLowerCase() === s.charAt(0).toLowerCase()) valid=false;
                    attempts++;
                } while(!valid && attempts<20);
                
                const foundVowel = s.split('').find(char => VOKALE_LISTE.includes(char) || DIPHTHONGE_LISTE.includes(char));
                if (foundVowel) lastVowel = foundVowel;

                res.push(s);
            }
            return res;
        }

        function handleResult(success) {
            if(state.game.isProcessing) return;
            state.game.isProcessing = true;
            
            if (success) {
                state.game.richtig++;
                const dur = Date.now() - state.game.wordStartTime;
                let f = 1.0; if(dur<2000) f=2.0; else if(dur>5000) f=0.5;
                spawnParticles(f);
            }
            state.game.runde++;
            setTimeout(nextCard, 300);
        }

        // --- SWIPE & PHYSICS ---
        function initSwipeLogic() {
            let startX = 0, isDragging = false; const card = dom.card.swipe; const content = dom.card.content;
            const start = (x) => { if (state.game.finished) return; startX = x; isDragging = true; card.style.transition = 'none'; };
            const move = (x) => {
                if (!isDragging) return; const diff = x - startX; card.style.transform = `translate(${diff}px, 0) rotate(${diff * 0.05}deg)`;
                const op = Math.min(Math.abs(diff) / 150, 0.3);
                if (diff > 0) { content.style.backgroundColor = `rgba(34, 197, 94, ${0.1 + op * 0.5})`; dom.card.overlay.innerHTML = `<svg class="w-32 h-32 text-green-600 drop-shadow-md" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="4" d="M5 13l4 4L19 7"></path></svg>`; } 
                else { content.style.backgroundColor = `rgba(107, 114, 128, ${0.1 + op * 0.5})`; dom.card.overlay.innerHTML = `<svg class="w-32 h-32 text-gray-600 drop-shadow-md" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="4" d="M6 18L18 6M6 6l12 12"></path></svg>`; }
                dom.card.overlay.style.opacity = Math.min(Math.abs(diff) / 100, 1);
            };
            const end = (x) => {
                if (!isDragging) return; isDragging = false; const diff = x - startX;
                if (Math.abs(diff) > 100) { const dir = diff > 0 ? 1 : -1; card.style.transition = 'transform 0.2s ease-out'; card.style.transform = `translate(${dir * 500}px, 0) rotate(${dir * 45}deg)`; handleResult(dir === 1); } 
                else { card.style.transition = 'transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)'; card.style.transform = 'translate(0,0) rotate(0)'; content.style.backgroundColor = 'white'; dom.card.overlay.style.opacity = '0'; }
            };
            card.addEventListener('touchstart', e => start(e.touches[0].clientX)); window.addEventListener('touchmove', e => move(e.touches[0].clientX)); window.addEventListener('touchend', e => end(e.changedTouches[0].clientX));
            card.addEventListener('mousedown', e => start(e.clientX)); window.addEventListener('mousemove', e => move(e.clientX)); window.addEventListener('mouseup', e => end(e.clientX));
        }
        function startPhysics() {
            stopPhysics(); const container = document.getElementById('2d-canvas-container');
            engine = Matter.Engine.create({ enableSleeping: true }); world = engine.world;
            render = Matter.Render.create({ element: container, engine: engine, options: { width: container.clientWidth, height: container.clientHeight, wireframes: false, background: 'transparent' } });
            
            // --- Ã„NDERUNG: BOUNDS CHECK & CLAMPING ---
            Matter.Events.on(engine, 'beforeUpdate', function() {
                const bodies = Matter.Composite.allBodies(engine.world);
                const w = render.canvas.width;
                const h = render.canvas.height;
                const pad = 30; // Puffer

                for (let i = 0; i < bodies.length; i++) {
                    const b = bodies[i];
                    if (b.label === 'wall') continue;
                    
                    // Clamping: Wenn Ball zu weit drauÃŸen, zurÃ¼cksetzen
                    if (b.position.x < -pad) Matter.Body.setPosition(b, { x: w + pad, y: b.position.y });
                    else if (b.position.x > w + pad) Matter.Body.setPosition(b, { x: -pad, y: b.position.y });
                    
                    if (b.position.y > h + pad) {
                        // Wenn unten raus (sollte nicht passieren wegen Boden), oben rein
                        Matter.Body.setPosition(b, { x: b.position.x, y: -pad });
                        Matter.Body.setVelocity(b, { x: b.velocity.x, y: 0 });
                    }
                }
                
                // If in bonus phase and empty (Time Mode Logic), go to end
                if (state.game.inBonusPhase && !state.game.isVortexing) { // Nur checken wenn kein Wirbel
                     // GEÃ„NDERT: LABEL 'ball' wird verwendet fÃ¼r korrekten Count
                     const remaining = bodies.filter(b => b.label === 'ball').length;
                     if (remaining === 0 && !state.game.transitioningToEnd) {
                         state.game.transitioningToEnd = true;
                         setTimeout(showEnd, 1000);
                     }
                }
            });
            
            // --- Ã„NDERUNG: COLLISION START FOR VIBRATION ---
            Matter.Events.on(engine, 'collisionStart', (event) => {
                if (state.settings.mode !== 'time') return; // Only time mode

                event.pairs.forEach((pair) => {
                    const bodyA = pair.bodyA;
                    const bodyB = pair.bodyB;
                    
                    let ball = null;
                    let floor = null;

                    if (bodyA.isFloor) floor = bodyA;
                    else if (!bodyA.isStatic && bodyA.label !== 'wall') ball = bodyA;

                    if (bodyB.isFloor) floor = bodyB;
                    else if (!bodyB.isStatic && bodyB.label !== 'wall') ball = bodyB;

                    if (ball && floor && !ball.hasHitFloor) {
                        ball.hasHitFloor = true;
                        if (navigator.vibrate) navigator.vibrate(15); 
                    }
                });
            });

            createWalls(container.clientWidth, container.clientHeight);

            (function loop() { if (!engine || !render) return; window.requestAnimationFrame(loop); Matter.Engine.update(engine, 1000/60);
                const ctx = render.context; ctx.clearRect(0, 0, w = render.canvas.width, h = render.canvas.height); ctx.save();
                state.view.zoom += (state.view.targetZoom - state.view.zoom) * 0.05;
                ctx.translate(w/2, h/2); ctx.scale(state.view.zoom, state.view.zoom); ctx.translate(-w/2, -h/2);
                Matter.Composite.allBodies(world).forEach(b => {
                    if (b.label === 'wall' || (b.label === 'stirrer' && !b.render.visible)) return;
                    ctx.beginPath(); ctx.arc(b.position.x, b.position.y, b.circleRadius, 0, 2*Math.PI);
                    ctx.fillStyle = b.render.fillStyle; ctx.fill();
                });
                ctx.restore();
            })(); physicsActive = true;
        }
        function stopPhysics() { engine = null; render = null; physicsActive = false; document.getElementById('2d-canvas-container').innerHTML = ''; }
        function resizePhysics() { if(!render) return; render.canvas.width = document.getElementById('2d-canvas-container').clientWidth; render.canvas.height = document.getElementById('2d-canvas-container').clientHeight; createWalls(render.canvas.width, render.canvas.height); }
        
        // UPDATE CREATEWALLS TO TAG FLOOR
        function createWalls(w, h) { 
            if(!world) return; 
            Matter.Composite.clear(world, false, true); 
            const th = 200; 
            const opts = { isStatic: true, label: 'wall', friction: 1, restitution: 0 }; 
            // Bottom wall gets isFloor tag
            Matter.Composite.add(world, [
                Matter.Bodies.rectangle(w/2, h+th/2, w+200, th, { ...opts, isFloor: true }), 
                Matter.Bodies.rectangle(-th/2, h/2, th, h*2, opts), 
                Matter.Bodies.rectangle(w+th/2, h/2, th, h*2, opts)
            ]); 
        }
        
        function spawnParticles(factor=1) { if(!engine) return; const w = render.canvas.width; const h = render.canvas.height;
            // Target value now depends on mode
            const targetVal = state.settings.mode === 'count' ? state.settings.targetCount : state.settings.targetTime;
            
            if(state.settings.mode === 'time') {
                const body = Matter.Bodies.circle(Math.random()*w*0.8+w*0.1, -50, 45, { restitution: 0.1, friction: 0.5, render: { fillStyle: RAINBOW_COLORS[state.game.colorIndex] }, label: 'ball' });
                Matter.Composite.add(world, body);
            } else {
                let count = Math.floor(((w*h*0.85)/(Math.PI*15*15*3)/targetVal)*1.5 * factor);
                if(count<10) count=10; if(count>150) count=150;
                for(let i=0; i<count; i++) {
                    const body = Matter.Bodies.circle(Math.random()*w*0.8+w*0.1, -Math.random()*300-50, 15, { restitution: 0.1, friction: 0.5, render: { fillStyle: RAINBOW_COLORS[state.game.colorIndex] }, label: 'ball' });
                    Matter.Composite.add(world, body);
                }
            }
            state.game.colorIndex = (state.game.colorIndex+1)%RAINBOW_COLORS.length;
        }
        function adjustFontSize() { 
            // Scale based on container size to fit both article and word
            const container = dom.card.textContainer;
            const word = dom.card.text;
            const article = dom.card.artikel;
            
            // Initial reset
            container.style.fontSize = '4rem'; // Start big
            
            // Check overflow
            let size = 4;
            
            const checkOverflow = () => {
                const totalWidth = word.offsetWidth + (article.classList.contains('hidden') ? 0 : article.offsetWidth) + 30; // + gap/padding
                const containerWidth = container.clientWidth;
                return totalWidth > containerWidth || container.scrollHeight > container.clientHeight;
            };

            while (checkOverflow() && size > 1) {
                size -= 0.2;
                container.style.fontSize = `${size}rem`;
            }
        }
        
        // --- GEÃ„NDERT: STIRRER REMOVAL ON END ---
        function endStirrer(e) {
            if(stirrer && engine) {
                Matter.Composite.remove(engine.world, stirrer);
                stirrer = null;
            }
        }

        function moveStirrer(e) {
            // Nur erlauben, wenn fertig UND im Count Mode
            if (!state.game.finished || state.settings.mode !== 'count') return;
            
            // Verhindern, dass Touch-Scrolling passiert
            if(e.type === 'touchmove') e.preventDefault();
            
            let x = e.touches ? e.touches[0].clientX : e.clientX; 
            let y = e.touches ? e.touches[0].clientY : e.clientY;
            
            // GEÃ„NDERT: Radius 100, Waking Up nearby bodies
            if (!stirrer && engine) { 
                stirrer = Matter.Bodies.circle(x, y, 100, { 
                    isStatic: true, 
                    label: 'stirrer',
                    render: { visible: false } 
                }); 
                Matter.Composite.add(engine.world, stirrer); 
            } else if (stirrer) {
                // Update position more aggressively
                Matter.Body.setPosition(stirrer, {x, y});
                // Ensure velocity is reset so it doesn't drift
                Matter.Body.setVelocity(stirrer, { x: 0, y: 0 });

                // Wake up nearby bodies for better responsiveness
                const nearby = Matter.Query.region(Matter.Composite.allBodies(engine.world), {
                    min: { x: x - 120, y: y - 120 },
                    max: { x: x + 120, y: y + 120 }
                });
                nearby.forEach(b => {
                    if (!b.isStatic) Matter.Sleeping.set(b, false);
                });
            }
        }
        
        function handleInteractionStart(e) {
            // Stirrer logic on touch start (count mode)
            if(state.game.finished && state.settings.mode === 'count') {
                moveStirrer(e);
                return;
            }

            // Pop logic (time mode only)
            if(!state.game.finished || state.settings.mode !== 'time') return;
            
            const x = e.touches ? e.touches[0].clientX : e.clientX; const y = e.touches ? e.touches[0].clientY : e.clientY;
            const clicked = Matter.Query.point(Matter.Composite.allBodies(world), {x, y});
            let removed = false;
            clicked.forEach(b => { 
                // ONLY REMOVE BALLS
                if(b.label === 'ball') { 
                    Matter.Composite.remove(world, b); 
                    createConfetti(b.position.x, b.position.y, b.render.fillStyle); 
                    removed=true; 
                } 
            });
            
            if (removed && navigator.vibrate) {
                 navigator.vibrate(40); // HAPTIC FEEDBACK POP
            }
        }
        function createConfetti(x, y, c) {
            for(let i=0; i<30; i++) { 
                const p = Matter.Bodies.circle(x, y, 4, { 
                    label: 'confetti', 
                    render: { fillStyle: c }, 
                    frictionAir: 0.02, 
                    restitution: 0.6 
                }); 
                Matter.Body.setVelocity(p, { x: (Math.random()-0.5)*30, y: (Math.random()-0.5)*30 }); 
                Matter.Composite.add(world, p); 
                setTimeout(() => { if(world) Matter.Composite.remove(world, p); }, 1000 + Math.random() * 2000); 
            }
        }

        function saveSettings() {
            // FIX: Use buchstabenList instead of container
            const checked = dom.inputs.buchstabenList.querySelectorAll('input:checked');
            const d = { 
                heftIndex: state.settings.heftIndex, 
                buchstaben: Array.from(checked).map(c => c.value), 
                minSilben: parseInt(dom.inputs.min.value), 
                maxSilben: parseInt(dom.inputs.max.value), 
                mode: state.settings.mode, 
                targetCount: state.settings.targetCount,
                targetTime: state.settings.targetTime,
                farben: dom.inputs.color.checked, 
                abstand: dom.inputs.gap.checked,
                showArticles: dom.inputs.artikel.checked, // NEU
                manualSyllables: state.settings.manualSyllables 
            };
            if (d.minSilben > d.maxSilben) d.minSilben = d.maxSilben;
            state.settings = d; try { localStorage.setItem('leseAppConf', JSON.stringify(d)); } catch(e) {}
        }
        function ladeEinstellungen() {
            // Default: mode: 'time', manualSyllables: false
            let d = { heftIndex: 1, buchstaben: ['A','M','O','L','I'], minSilben: 1, maxSilben: 2, mode: 'time', targetCount: 10, targetTime: 5, farben: true, abstand: false, showArticles: false, manualSyllables: false };
            try { const s = localStorage.getItem('leseAppConf'); if(s) { const p = JSON.parse(s); d = {...d, ...p}; } } catch(e){}
            state.settings = d; 
            dom.inputs.min.value = d.minSilben; 
            dom.inputs.max.value = d.maxSilben; 
            dom.inputs.color.checked = d.farben; 
            dom.inputs.gap.checked = d.abstand;
            dom.inputs.artikel.checked = d.showArticles; // NEU
            
            // Set mode and value
            dom.inputs.modeSelect.value = d.mode;
            dom.inputs.modeValue.value = d.mode === 'count' ? d.targetCount : d.targetTime;
            
            // Switch Mode logic manually
            // We reuse switchMode logic but without saving yet
            // Actually ladeEinstellungen populates state.settings, so we are good.
            
            selectHeft(parseInt(d.heftIndex || 1));
        }
    </script>
</body>
</html>
